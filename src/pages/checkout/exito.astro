---
import PublicLayout from "@/layouts/PublicLayout.astro";
import Button from "@/components/ui/Button.astro";
import { supabase, supabaseAdmin } from "@/lib/supabase";
import { stripe } from "@/lib/stripe";
import { sendOrderConfirmation, sendAdminOrderNotification } from "@/lib/email";
import { formatOrderId } from "@/lib/order-utils";
import { formatPrice } from "@/lib/formatters";

const sessionId = Astro.url.searchParams.get("session_id");

let order = null;
let orderItems: any[] = [];
let emailSent = false;
let couponInfo: { code: string; discountAmount: number } | null = null;

if (sessionId) {
  try {
    // Get session from Stripe to confirm payment
    const session = await stripe.checkout.sessions.retrieve(sessionId);

    if (session.payment_status === "paid" && session.metadata?.order_id) {
      // Get current order status first using service role (bypasses RLS)
      const { data: existingOrder } = await supabaseAdmin
        .from("orders")
        .select("status")
        .eq("id", session.metadata.order_id)
        .single();

      const wasAlreadyPaid = existingOrder?.status === "paid";

      console.log(
        `Order status before update: ${existingOrder?.status}, wasAlreadyPaid: ${wasAlreadyPaid}`,
      );

      // Update order status to paid (backup in case webhook didn't fire)
      const { error: updateError } = await supabase.rpc("update_order_status", {
        p_stripe_session_id: sessionId,
        p_status: "paid",
      });

      if (updateError) {
        console.error(
          "Error updating order status in success page:",
          updateError,
        );
      } else {
        console.log("Order status updated to paid via success page");
      }

      // Update total_amount with Stripe's actual charged amount (reflects coupon discount)
      if (session.amount_total != null && session.metadata?.order_id) {
        const stripeFinalAmount = session.amount_total / 100;
        await supabaseAdmin
          .from("orders")
          .update({ total_amount: stripeFinalAmount })
          .eq("id", session.metadata.order_id);
      }

      // Record coupon usage if present (backup for webhook)
      if (session.metadata?.coupon_id) {
        const couponId = session.metadata.coupon_id;
        console.log("Attempting to record coupon usage:", couponId);

        const { error: couponError } = await supabase.rpc("use_coupon", {
          p_coupon_id: couponId,
          p_customer_email:
            session.customer_details?.email || session.customer_email || "",
          p_order_id: session.metadata.order_id,
        });

        if (couponError) {
          // Ignore unique constraint violation (already recorded by webhook)
          if (couponError.code !== "23505") {
            console.error(
              "Error recording coupon usage in success page:",
              couponError,
            );
          } else {
            console.log("Coupon already recorded (likely by webhook)");
          }
        } else {
          console.log("Coupon usage recorded via success page");
        }
      }

      // Get order details
      console.log("üõí [CHECKOUT SUCCESS] Fetching order details...");
      console.log(
        "üõí [CHECKOUT SUCCESS] Order ID from session:",
        session.metadata.order_id,
      );
      console.log(
        "üõí [CHECKOUT SUCCESS] Using client type:",
        "supabaseAdmin (service role)",
      );

      const { data: orderData, error: orderFetchError } = await supabaseAdmin
        .from("orders")
        .select("*, order_number")
        .eq("id", session.metadata.order_id)
        .single();

      if (orderFetchError) {
        console.error("üõí [CHECKOUT SUCCESS] ‚ùå Error fetching order:", {
          code: orderFetchError.code,
          message: orderFetchError.message,
          details: orderFetchError.details,
          hint: orderFetchError.hint,
          orderId: session.metadata.order_id,
        });
      } else {
        console.log("üõí [CHECKOUT SUCCESS] ‚úÖ Order fetched successfully");
      }

      order = orderData;
      console.log(
        `üõí [CHECKOUT SUCCESS] Order result: ${order ? "YES" : "NO"}, order_number: ${order?.order_number}, email: ${order?.customer_email}, status: ${order?.status}`,
      );

      if (order) {
        // Get order items with product info using service role
        const { data: items } = await supabaseAdmin
          .from("order_items")
          .select(
            `
            *,
            products (name),
            product_variants (size)
          `,
          )
          .eq("order_id", order.id);

        orderItems = items || [];

        // Read coupon info from order DB columns (set at creation time)
        if (order.coupon_code && Number(order.discount_amount || 0) > 0) {
          couponInfo = {
            code: order.coupon_code,
            discountAmount: Number(order.discount_amount),
          };
        }

        // Send confirmation email if webhook didn't already do it
        // (check if order was already paid before we updated it)
        console.log(
          `Checking email sending: wasAlreadyPaid=${wasAlreadyPaid}, customerEmail=${order.customer_email}`,
        );

        if (!wasAlreadyPaid && order.customer_email) {
          console.log(
            "Attempting to send confirmation email from success page...",
          );

          try {
            const emailItems = orderItems.map((item: any) => ({
              productName: item.products?.name || "Producto",
              size: item.product_variants?.size || "-",
              quantity: item.quantity,
              price: Number(item.price_at_purchase),
            }));

            console.log("Email items prepared:", emailItems.length);

            const result = await sendOrderConfirmation({
              orderId: order.id,
              orderNumber: order.order_number,
              customerName: order.customer_name,
              customerEmail: order.customer_email,
              shippingAddress: order.shipping_address,
              shippingCity: order.shipping_city,
              shippingPostalCode: order.shipping_postal_code,
              shippingCountry: order.shipping_country || "Espa√±a",
              totalAmount: Number(order.total_amount),
              shippingCost: Number(order.shipping_cost || 0),
              items: emailItems,
              ...(couponInfo ? { couponCode: couponInfo.code, discountAmount: couponInfo.discountAmount } : {}),
            });

            emailSent = result.success;
            if (!result.success) {
              console.error("Failed to send confirmation email:", result.error);
            } else {
              console.log(
                "‚úÖ Confirmation email sent successfully from success page",
              );

              // Marcar email como enviado (idempotencia para el webhook)
              await supabaseAdmin
                .from("orders")
                .update({ confirmation_email_sent: true })
                .eq("id", order.id);

              // Enviar notificaci√≥n al admin (awaited para garantizar entrega)
              try {
                const adminResult = await sendAdminOrderNotification({
                  orderId: order.id,
                  orderNumber: order.order_number,
                  customerName: order.customer_name,
                  customerEmail: order.customer_email,
                  totalAmount: Number(order.total_amount),
                  items: emailItems,
                  shippingCity: order.shipping_city,
                  shippingAddress: order.shipping_address,
                });
                if (adminResult.success) {
                  console.log("‚úÖ Admin order notification sent from success page");
                } else {
                  console.error("Failed to send admin notification:", adminResult.error);
                }
              } catch (adminError) {
                console.error("Exception sending admin notification:", adminError);
              }
            }
          } catch (emailError) {
            console.error("Exception sending confirmation email:", emailError);
          }
        } else {
          console.log(
            `Email NOT sent: wasAlreadyPaid=${wasAlreadyPaid}, has email=${!!order.customer_email}`,
          );
        }
      }
    }
  } catch (error) {
    console.error("Error fetching order:", error);
  }
}

function formatDate(date: string): string {
  return new Intl.DateTimeFormat("es-ES", {
    dateStyle: "long",
    timeStyle: "short",
  }).format(new Date(date));
}
---

<PublicLayout title="¬°Pedido Confirmado! - FashionStore">
  <div class="container mx-auto px-4 py-12">
    <!-- Confetti Canvas -->
    <canvas id="confetti-canvas" class="fixed inset-0 pointer-events-none z-50"
    ></canvas>

    <div class="max-w-2xl mx-auto text-center">
      <!-- Success Icon -->
      <div
        class="w-24 h-24 mx-auto mb-8 bg-emerald-500/20 rounded-full flex items-center justify-center animate-bounce-in"
      >
        <svg
          class="w-12 h-12 text-emerald-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M5 13l4 4L19 7"></path>
        </svg>
      </div>

      <h1 class="font-display text-4xl md:text-5xl mb-4">
        ¬°Gracias por tu pedido!
      </h1>
      <p class="text-xl text-muted-foreground mb-8">
        Tu pago ha sido procesado correctamente. Te hemos enviado un email de
        confirmaci√≥n.
      </p>

      {
        order && (
          <div class="bg-card border border-border rounded-xl p-6 md:p-8 text-left mb-8">
            <div class="flex items-center justify-between mb-6 pb-6 border-b border-border">
              <div>
                <p class="text-sm text-muted-foreground">N√∫mero de pedido</p>
                <p class="font-mono text-sm mt-1">
                  {order.order_number
                    ? formatOrderId(order.order_number)
                    : order.id?.slice(0, 8).toUpperCase()}
                </p>
              </div>
              <div class="text-right">
                <p class="text-sm text-muted-foreground">Fecha</p>
                <p class="text-sm mt-1">{formatDate(order.created_at)}</p>
              </div>
            </div>

            <div class="mb-6">
              <h3 class="font-heading font-semibold mb-3">
                Direcci√≥n de env√≠o
              </h3>
              <p class="text-muted-foreground text-sm">
                {order.customer_name}
                <br />
                {order.shipping_address}
                <br />
                {order.shipping_postal_code} {order.shipping_city}
                <br />
                {order.shipping_country}
              </p>
            </div>

            <div class="mb-6">
              <h3 class="font-heading font-semibold mb-3">Productos</h3>
              <div class="space-y-3">
                {orderItems.map((item) => (
                  <div class="flex justify-between text-sm">
                    <span>
                      {item.products?.name || "Producto"}
                      <span class="text-muted-foreground">
                        (Talla {item.product_variants?.size})
                      </span>
                      <span class="text-muted-foreground">
                        {" "}
                        √ó {item.quantity}
                      </span>
                    </span>
                    <span class="font-medium">
                      {formatPrice(item.price_at_purchase * item.quantity)}
                    </span>
                  </div>
                ))}
              </div>
            </div>

            {Number(order.shipping_cost || 0) > 0 && (
              <div class="flex justify-between text-sm py-2">
                <span class="text-muted-foreground">Env√≠o</span>
                <span class="font-medium">
                  {formatPrice(Number(order.shipping_cost))}
                </span>
              </div>
            )}

            {couponInfo && couponInfo.discountAmount > 0 && (
              <div class="flex justify-between text-sm py-2 text-emerald-600">
                <span>
                  Descuento (cup√≥n <span class="font-mono font-medium">{couponInfo.code}</span>)
                </span>
                <span class="font-medium">
                  -{formatPrice(couponInfo.discountAmount)}
                </span>
              </div>
            )}

            <div class="pt-4 border-t border-border flex justify-between text-lg font-bold">
              <span>Total</span>
              <span class="text-primary">
                {formatPrice(order.total_amount)}
              </span>
            </div>
          </div>
        )
      }

      <div class="flex flex-col sm:flex-row gap-4 justify-center">
        <Button href="/productos" variant="primary" size="lg">
          Seguir comprando
        </Button>
      </div>

      <p class="text-sm text-muted-foreground mt-6">
        Te hemos enviado un email de confirmaci√≥n a tu correo electr√≥nico.
      </p>
    </div>
  </div>

  <script>
    import { clearCart, $cart } from "@/stores/cart";

    // Clear cart on success page with verification
    try {
      clearCart();

      // Verify cart was cleared
      setTimeout(() => {
        if ($cart.get().length > 0) {
          console.warn("Cart not properly cleared, retrying...");
          localStorage.removeItem("fashionstore_cart");
          clearCart();
        }
      }, 100);
    } catch (e) {
      console.error("Error clearing cart:", e);
      // Fallback: clear localStorage directly
      try {
        localStorage.removeItem("fashionstore_cart");
      } catch {}
    }

    // Confetti animation
    const canvas = document.getElementById(
      "confetti-canvas",
    ) as HTMLCanvasElement;
    const ctx = canvas.getContext("2d");

    if (ctx) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const colors = ["#CCFF00", "#FF4757", "#3b82f6", "#10b981", "#f59e0b"];
      const confetti: {
        x: number;
        y: number;
        r: number;
        d: number;
        color: string;
        tilt: number;
        tiltAngle: number;
        tiltAngleIncrement: number;
      }[] = [];

      // Create confetti particles
      for (let i = 0; i < 150; i++) {
        confetti.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          r: Math.random() * 6 + 4,
          d: Math.random() * 150 + 10,
          color: colors[Math.floor(Math.random() * colors.length)] ?? "#CCFF00",
          tilt: Math.floor(Math.random() * 10) - 10,
          tiltAngle: 0,
          tiltAngleIncrement: Math.random() * 0.07 + 0.05,
        });
      }

      let frameCount = 0;
      const maxFrames = 200;

      function draw() {
        if (!ctx || frameCount >= maxFrames) {
          canvas.style.display = "none";
          return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const c of confetti) {
          ctx.beginPath();
          ctx.lineWidth = c.r / 2;
          ctx.strokeStyle = c.color;
          ctx.moveTo(c.x + c.tilt + c.r / 4, c.y);
          ctx.lineTo(c.x + c.tilt, c.y + c.tilt + c.r / 4);
          ctx.stroke();
        }

        // Update positions
        for (const c of confetti) {
          c.y += (Math.cos(c.d) + 3 + c.r / 2) / 2;
          c.x += Math.sin(c.d);
          c.tiltAngle += c.tiltAngleIncrement;
          c.tilt = Math.sin(c.tiltAngle) * 15;
        }

        frameCount++;
        requestAnimationFrame(draw);
      }

      draw();
    }
  </script>

  <style>
    @keyframes bounceIn {
      0% {
        transform: scale(0);
        opacity: 0;
      }
      50% {
        transform: scale(1.2);
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .animate-bounce-in {
      animation: bounceIn 0.6s ease-out;
    }
  </style>
</PublicLayout>
